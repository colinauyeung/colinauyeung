<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>


</head>
<body>

<svg id="svg" viewBox="0 0 100 100" width="100%" height="900" preserveAspectRatio="xMidYMin meet"></svg>
<script src="https://d3js.org/d3.v5.min.js"></script>
<script src="js/get-float-time-domain-data.js"></script>

<script>

    const svg = d3.select("svg");

    const text = svg.append("text")
        .attr("fill", "black")
        .attr("x", 50)
        .attr("y", 50)
        .text("Hello v7");

    // window.addEventListener("load", (e) => {
    //     init();
    // })
    document.body.addEventListener('click', init);

    function init(){
        document.body.removeEventListener('click', init);
        var AC = window.AudioContext || window.webkitAudioContext;
        var audioContext = new AC();
        var microphone;





        if (navigator.mediaDevices.getUserMedia === undefined) {
            navigator.mediaDevices.getUserMedia = function(constraints) {

                // First get ahold of the legacy getUserMedia, if present
                var getUserMedia = navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia;

                // Some browsers just don't implement it - return a rejected promise with an error
                // to keep a consistent interface
                if (!getUserMedia) {
                    return Promise.reject(new Error('getUserMedia is not implemented in this browser'));
                }

                // Otherwise, wrap the call to the old navigator.getUserMedia with a Promise
                return new Promise(function(resolve, reject) {
                    getUserMedia.call(navigator, constraints, resolve, reject);
                });
            }
        }



        var analyzer = audioContext.createAnalyser();
        const gainNode = audioContext.createGain();
        if(navigator.mediaDevices.getUserMedia()){
            console.log("getUserMedia Supported");
            var constraints = {audio: true};
            navigator.mediaDevices.getUserMedia(constraints)
                .then(
                    function(stream){
                        microphone = audioContext.createMediaStreamSource(stream);
                        microphone.connect(gainNode);
                        gainNode.gain.value = 1;
                        gainNode.connect(analyzer);
;
                        analyzer.connect(audioContext.destination);

                        beginRecording(analyzer, audioContext.sampleRate);
                    })
                .catch(function(err){
                    console.log("Error! "+err)
                })
        }
        else{
            console.log("getUserMedia is not supported");
        }


    }

    function beginRecording(analyzer, sampleRate){
        analyzer.fftsize = 2048; //needs to be a power of 2, between 32 and MAX UNSIGNED INT
        var bufferlength = analyzer.fftsize;
        var freqBinDataArray = new Float32Array( bufferlength );
        // var freqBinDataArray = new Uint8Array(bufferlength);

        var checkAudio = function (){
            analyzer.getFloatTimeDomainData( freqBinDataArray );
            var ac = autoCorrelate( freqBinDataArray ,sampleRate);
            text.text(ac);
            // analyzer.getByteTimeDomainData(freqBinDataArray);
            console.log(freqBinDataArray);
            console.log(ac);
            console.log("RMS: "+ getRMS(freqBinDataArray));
            console.log("Dominate Freq: " + getIndexofMax(freqBinDataArray));
        }
        setInterval(checkAudio, 64);
    }




    function autoCorrelate( buf, sampleRate ) {
        // Implements the ACF2+ algorithm
        var SIZE = buf.length;
        var rms = 0;

        for (var i=0;i<SIZE;i++) {
            var val = buf[i];
            rms += val*val;
        }
        rms = Math.sqrt(rms/SIZE);
        if (rms<0.01) // not enough signal
            return -1;

        var r1=0, r2=SIZE-1, thres=0.2;
        for (var i=0; i<SIZE/2; i++)
            if (Math.abs(buf[i])<thres) { r1=i; break; }
        for (var i=1; i<SIZE/2; i++)
            if (Math.abs(buf[SIZE-i])<thres) { r2=SIZE-i; break; }

        buf = buf.slice(r1,r2);
        SIZE = buf.length;

        var c = new Array(SIZE).fill(0);
        for (var i=0; i<SIZE; i++)
            for (var j=0; j<SIZE-i; j++)
                c[i] = c[i] + buf[j]*buf[j+i];

        var d=0; while (c[d]>c[d+1]) d++;
        var maxval=-1, maxpos=-1;
        for (var i=d; i<SIZE; i++) {
            if (c[i] > maxval) {
                maxval = c[i];
                maxpos = i;
            }
        }
        var T0 = maxpos;

        var x1=c[T0-1], x2=c[T0], x3=c[T0+1];
        a = (x1 + x3 - 2*x2)/2;
        b = (x3 - x1)/2;
        if (a) T0 = T0 - b/(2*a);

        return sampleRate/T0;
    }

    function getRMS(spectrum){
        var rms = 0;
        for (var i = 0; i < spectrum.length; i++){
            rms += spectrum[i] * spectrum[i];
        }
        rms /= spectrum.length;
        rms = Math.sqrt(rms);
        return rms
    }

    function  getIndexofMax(array){
        return array.reduce((iMax, x, i, arr) => x > arr[iMax]? i : iMax,0
        )
    }


</script>
</body>
</html>